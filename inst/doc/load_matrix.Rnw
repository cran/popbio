% \VignetteIndexEntry{Loading projection matrices}
\documentclass[12pt]{article}

\usepackage{Sweave}

\usepackage{fullpage}
\usepackage{hyperref}

\newcommand{\R}{\textsf{R}}
\newcommand{\Rcmd}[1]{\texttt{#1}}


\title{Loading projection matrices into \R }
\author{Chris Stubben}
\date{\today}


\begin{document}
\maketitle
\SweaveOpts{prefix.string=plot, strip.white=false}

%% for cutting and pasting use continue =""

%% also, I cannot get scan to work in code chunks, so put "scanned"
%% matrices here (use dput to print R code)
<<setup, echo=FALSE, results=hide>>=
library(popbio)
library(lattice)
options(warn=-1, width=70, digits=3, scipen=3,  "prompt" = "R> ", "continue" = "  ")

ceco<-c(0,0,5.905,0.368,0.639, 0.025, 0.001, 0.152, 0.051)

x1<-c("Recruit", "0.0000", "(0)", "0.0000", "(0)", "0.0000", "(0)", 
"4.0000", "(0)", "Juvenile", "0.1000", "(2)", "0.9540", "(61)", 
"0.0900", "(2)", "0.0000", "(0)", "Non-flowering", "adult", "0.0000", 
"(0)", "0.0360", "(3)", "0.7010", "(18)", "0.8375", "(5)", "Flowering", 
"adult", "0.0000", "(0)", "0.0000", "(0)", "0.1802", "(6)", "0.1610", 
"(1)")

x2<-c("pod", "n", "G1", "G2", "G3", "P2", "P3", "P4", "F2", "F3", 
"J01", "22", "0.9535", "0.0802", "0.0414", "0.8827", "0.9586", 
"0.9752", "0.0067", "0.1632", "K01", "20", "1.0000", "0.0694", 
"0.0418", "0.9020", "0.9582", "0.9855", "0.0062", "0.1737", "L01", 
"63", "0.9562", "0.0722", "0.0406", "0.9030", "0.9530", "0.9798", 
"0.0037", "0.0988", "A01", "15", "1.0000", "0.0727", "0.0485", 
"0.9015", "0.9515", "0.9667", "0.0043", "0.1148", "A04", "12", 
"0.8165", "0.0774", "0.0485", "0.8903", "0.9515", "0.9810", "0.0042", 
"0.1054", "A05", "10", "1.0000", "0.0730", "0.0485", "0.9123", 
"0.9515", "0.9545", "0.0027", "0.0732", "B01", "8", "1.0000", 
"0.0746", "0.0485", "0.9254", "0.9515", "0.9810", "0.0025", "0.0651", 
"C01", "8", "1.0000", "0.0800", "0.0294", "0.9200", "0.9706", 
"0.9608", "0.0047", "0.1159", "D01", "12", "1.0000", "0.0759", 
"0.0438", "0.9241", "0.9562", "1.0000", "0.0068", "0.1761", "G01", 
"24", "1.0000", "0.0833", "0.0714", "0.9167", "0.9286", "1.0000", 
"0.0061", "0.1418", "G12", "11", "1.0000", "0.0784", "0.0485", 
"0.9216", "0.9515", "0.9810", "0.0050", "0.1251", "H01", "7", 
"1.0000", "0.0746", "0.0485", "0.9254", "0.9515", "0.9810", "0.0021", 
"0.0542", "I01", "7", "1.0000", "0.0714", "0.0485", "0.9286", 
"0.9515", "0.9810", "0.0027", "0.0732", "I02", "7", "1.0000", 
"0.0714", "0.0485", "0.9286", "0.9515", "1.0000", "0.0045", "0.1220", 
"I11", "15", "1.0000", "0.0714", "0.0485", "0.9286", "0.9515", 
"0.9810", "0.0052", "0.1428", "I18", "13", "1.0000", "0.0714", 
"0.0485", "0.9286", "0.9515", "0.9810", "0.0037", "0.0998", "I31", 
"7", "1.0000", "0.0714", "0.0485", "0.9286", "0.9515", "0.9810", 
"0.0047", "0.1273", "R01", "20", "1.0000", "0.0595", "0.0485", 
"0.8929", "0.9515", "1.0000", "0.0024", "0.0797")


@

 This guide describes how to load projection matrices into \R~using a
number of examples from published demographic studies.  At least for small matrices, one option is to combine matrix
elements into a comma-separated list of values using \Rcmd{c()} and
then use \Rcmd{matrix} to reshape the vector into a square matrix.

<<A>>=
A<-c(0, 0.3, 0, 1, 0, 0.5, 5, 0, 0)
A<-matrix(A, nrow=3)
@ 

The following examples expand on this simple case by using two methods, either copying and pasting a matrix using
\Rcmd{scan} or reading a matrix into \R~using \Rcmd{read.table} and
related functions. 


\section*{Loading matrices using scan}
If a  projection matrix is part of a larger PDF or
HTML document, you can often copy  and paste the matrix elements  directly into
the \R~console after typing the \Rcmd{scan} command. In this first example, the mean matrix for
\emph{Centaurea corymbosa} was copied from the first row in Table 1
from Freville et al (2004) and pasted below.


\begin{Sinput}
R> ceco<-scan()
0 0 5.905 0.368 0.639 0.025 0.001 0.152 0.051     
\end{Sinput}

Be sure to enter a blank line to terminate the input on the screen.
At the R terminal, your screen should look something like this if
done successfully.


\begin{Sinput}
R> ceco<-scan()
1: 0 0 5.905 0.368 0.639 0.025 0.001 0.152 0.051
10: 
Read 9 items
\end{Sinput}

Next, create a vector of stages to assign to the row and column names (i.e., the
dimension names) and then  use the \Rcmd{matrix} function to reshape
the vector by rows into a $3 \times 3$ matrix.  By default, a matrix
is filled by columns, but usually values are copied by rows, so the
\Rcmd{byrow} option should be set to TRUE. 

<<ceco>>=
stages <- c("seedling", "vegetative", "flowering")
matrix(ceco, nrow=3, byrow=TRUE, dimnames=list(stages,stages))


@ 

One of the nice features of \R~is the ability to create new
functions.  If the \Rcmd{matrix} command above is too tedious, you can
add your own function to simplify the creation of square
matrices. The \Rcmd{matrix2} command is also included in the latest
version of \Rcmd{popbio 2.3}.

<<ceco, eval=FALSE>>=
matrix2<-function(x, stages, byrow=TRUE){
   matrix(x, nrow=sqrt(length(x)), byrow=byrow, dimnames=list(stages, stages))
}
ceco<-matrix2(ceco, stages)
@ 

One final step after copying and pasting a matrix into \R~is to save
the matrix to a file for future analyses (and to avoid copying and
pasting again).  One option is to save a binary \R~data file using
\Rcmd{save} and then use \Rcmd{load} to reload the matrix object in
the future.  Another alternative is to write the matrix to a text file
using \Rcmd{write.table} and then use \Rcmd{read.table} to read the
file back into R.  Since this function always reads a file to a
\Rcmd{data.frame}, use \Rcmd{as.matrix} to convert to a matrix (matrix
multiplication and a few other functions will not work on
data.frames).  More details about \Rcmd{read.table} are found in the
second section of the guide.



<<write, eval=FALSE>>=
write.table(ceco, file="ceco.txt")
ceco<-as.matrix(read.table(file="ceco.txt"))
@


\subsection*{Scanning matrices with characters}
  
In most cases, a copy of a published matrix will include row names or additional values.
In the next example, the projection matrix for \emph{Sarracenia purpurea} at Hawley
Bog in Table 1 from Gotelli and Ellison (2006) is pasted below.  
By default, \Rcmd{scan} will read numeric data, so use
the \Rcmd{what} option to specify characters in order to read the stage class names (and elasticities in parentheses). 


\begin{Sinput}
R> x1<-scan(, what="")
Recruit 0.0000 (0) 0.0000 (0) 0.0000 (0) 4.0000 (0)
Juvenile 0.1000 (2) 0.9540 (61) 0.0900 (2) 0.0000 (0)
Non-flowering adult 0.0000 (0) 0.0360 (3) 0.7010 (18) 0.8375 (5)
Flowering adult 0.0000 (0) 0.0000 (0) 0.1802 (6) 0.1610 (1)
\end{Sinput}

In~\R, you can use the \Rcmd{grep} function and a regular expression
to list only  elements with digits or a decimal point.  The matching
elements are then converted to a numeric vector and the results are
reshaped into a square matrix.  In addition, stages (in position 1,
10, 19, 29) are assigned to the row and column names.  It is usually a
good idea to check the matrix by calculating lambda, elasticities, or other values
reported in the original paper.  In this case, the elasticities below
match the copied values in parentheses above (except for the flowering
to recruit transition).


<<sapu>>=
stages<-x1[c(1,10,19,29)]
sapu<-matrix2( as.numeric(grep("^[0-9.]+$", x1, value = TRUE)), stages)
sapu
round(elasticity(sapu)*100)
@ 



\subsection*{Scanning matrices with only non-zero elements}
In some cases, matrix elements from multiple sites or years will be
listed in a table,  and often these tables will only include transitions with non-zero elements.  There are a few ways
to create a projection matrix from these tables, but I'll focus on using a expression of matrix
elements since this technique is useful in many other situations.

First copy the pod-specific matrix elements for
killer whales from the appendix in Brault and Caswell (1993).


\begin{Sinput}
R> x2<-scan(, what="")
pod n G1 G2 G3 P2 P3 P4 F2 F3
J01 22 0.9535 0.0802 0.0414 0.8827 0.9586 0.9752 0.0067 0.1632
K01 20 1.0000 0.0694 0.0418 0.9020 0.9582 0.9855 0.0062 0.1737
L01 63 0.9562 0.0722 0.0406 0.9030 0.9530 0.9798 0.0037 0.0988
A01 15 1.0000 0.0727 0.0485 0.9015 0.9515 0.9667 0.0043 0.1148
A04 12 0.8165 0.0774 0.0485 0.8903 0.9515 0.9810 0.0042 0.1054
A05 10 1.0000 0.0730 0.0485 0.9123 0.9515 0.9545 0.0027 0.0732
B01 8 1.0000 0.0746 0.0485 0.9254 0.9515 0.9810 0.0025 0.0651
C01 8 1.0000 0.0800 0.0294 0.9200 0.9706 0.9608 0.0047 0.1159
D01 12 1.0000 0.0759 0.0438 0.9241 0.9562 1.0000 0.0068 0.1761
G01 24 1.0000 0.0833 0.0714 0.9167 0.9286 1.0000 0.0061 0.1418
G12 11 1.0000 0.0784 0.0485 0.9216 0.9515 0.9810 0.0050 0.1251
H01 7 1.0000 0.0746 0.0485 0.9254 0.9515 0.9810 0.0021 0.0542
I01 7 1.0000 0.0714 0.0485 0.9286 0.9515 0.9810 0.0027 0.0732
I02 7 1.0000 0.0714 0.0485 0.9286 0.9515 1.0000 0.0045 0.1220
I11 15 1.0000 0.0714 0.0485 0.9286 0.9515 0.9810 0.0052 0.1428
I18 13 1.0000 0.0714 0.0485 0.9286 0.9515 0.9810 0.0037 0.0998
I31 7 1.0000 0.0714 0.0485 0.9286 0.9515 0.9810 0.0047 0.1273
R01 20 1.0000 0.0595 0.0485 0.8929 0.9515 1.0000 0.0024 0.0797
\end{Sinput}

Second, format the scanned values into a matrix, select only the pod rates (by
skipping the first row and first two columns),  and add row and column labels.

<<pods>>=
x2<-matrix(x2, nrow=19, byrow=TRUE)
pods<-matrix(as.numeric(x2[-1,-(1:2)]), nrow=18)
dimnames(pods)<-list(x2[-1,1], x2[1,-(1:2)] )
head(pods)
@ 

Third, enter the  projection matrix from Fig 1 in Brault and Caswell
(1993) into an expression and include the commands to convert the
values into a square matrix with stage class names.
The symbols in this expression must match the column names in the matrix
of pod-specific rates above.  

<<podA, keep.source=TRUE>>=
podA<-expression(
  matrix2( c(
   0,  F2, F3, 0,
   G1, P2, 0,  0,
   0,  G2, P3, 0,
   0,  0,  G3, P4), 
    c("yearling", "juvenile", "mature", "postreprod"))) 
@

Fourth, evaluate the the \R~expression using a \Rcmd{list} of
matrix elements in the first row to get a projection matrix from a single pod.
 
<<J01>>=
J01 <- eval(podA, as.list(pods[1,]))
J01
@ 


Finally, you can include the previous step in a loop and create
projection matrices for all 18 pods. The dotplot in Figure~\ref{whales}
displays the pod-specific population growth rates.

<<whales, fig=TRUE, height=4, width=4, include=FALSE>>=
whales <- vector("list", 18)
 names(whales) <- rownames(pods)
 for (i in 1:18) {
  whales[[i]] <- eval(podA, as.list(pods[i,]))
}
print(dotplot( sort(  sapply(whales, lambda)), xlab="Growth rate"))
@ 


\begin{figure}[t]
  \begin{center}
\includegraphics[height=4in, width=4in]{plot-whales}
  \end{center}
  \caption{Growth rates for killer whale pods.}
    \label{whales}
\end{figure}



\section*{Loading matrices using read.table}

Perhaps the most common way to load a projection matrix is to read the
matrix from a file using \Rcmd{read.table}.  In this case, the file
may be stored locally or on the web and these files may include one or
more projection matrices. The formats of the files will
also vary, so it is often necessary to check and modify some of the
default \Rcmd{read.table} options.

In the next example, projection matrices for \emph{Silene acaulis} are
stored in the ESA Archives (Morris and Doak 2005, see
\url{http://www.esapubs.org/archive/mono/M075/004/default.htm} for
details).  To download the comma-separated matrix from Campion Crest
in 1995, use \Rcmd{read.table} and change the default separator to a
comma.

<<cc95a>>=
CC95<-read.table("http://www.esapubs.org/archive/mono/M075/004/CC95.txt", sep=",")
@ 

It is important to note again that \Rcmd{read.table}  loads the values into a data.frame, so you will need to convert this to a matrix,
and you will often need to add dimension names as well.  Finally, you can print or even
plot the projection matrix using \Rcmd{image2} to check the results
(Figure~\ref{silene}).

<<cc95, fig=TRUE, height=4, width=4, include=FALSE>>=

CC95<- as.matrix(CC95)
stages<-c("seed", "sdling", "1R", "5R", "10R", "20R", "12cm", "25cm", "50cm", "100cm", "200cm", "200+cm")
dimnames(CC95)<- list(stages,stages)
image2( CC95 , cex=.5, log=FALSE)
@


\begin{figure}[t]
  \begin{center}
\includegraphics[height=4in, width=4in]{plot-cc95}
  \end{center}
  \caption{Projection matrix for \emph{Silene acaulis} at Campion Crest in 1995.}
    \label{silene}
\end{figure}



Using a loop, you can also load multiple projection matrices into a list of matrices
(there are 25 total matrices from 5 sites, but this example just
includes 2 sites below, CC and GU.  Additional sites are PA, RG, and RI, but
loading PA98.txt will cause an error since the second row has two
different field separators).  The last command applies the \Rcmd{lambda}
function to all matrices in the list and returns the growth rates as a
vector.

<<silene>>=

years<-95:99
site<-c("CC", "GU")
pop<-paste(rep(site,each=5),years, sep="")
n<-length(pop)
silene<-vector('list', n) 
names(silene)<-pop
for ( i in 1:n)
{  
   x<-paste("http://www.esapubs.org/archive/mono/M075/004/", pop[i],".txt", sep="")
   y<-as.matrix(read.table(x,  sep=","))
   dimnames(y)<-list(stages,stages)
   silene[[i]]<-y
}

sapply(silene, lambda)
@

\subsection*{Loading matrices with HTML markup}

Many population matrices that are stored in web archives include HTML
formatting.  In these cases, you can often use \Rcmd{readLines} to download the
web page and then use a combination of \Rcmd{grep} to find matrix
elements and \Rcmd{gsub} to remove html tags.  For example, the
projection matrices from \emph{Ardisia elliptica} are also stored in the ESA archives (Koop and Horvitz 2005, see
\url{http://www.esapubs.org/archive/ecol/E086/142/appendix-E.htm}).
Use \Rcmd{readLines} to download the entire page including the HTML
markup.  Next, use the \Rcmd{grep} function to find 832 lines with a
matrix element between the html tags (since there are 13 matrices with 64
elements each).

<<arel>>=

arel<-readLines("http://www.esapubs.org/archive/ecol/E086/142/appendix-E.htm")
y<-grep(">[0-9.]+<",  arel) 
length(y)
@

Use \Rcmd{gsub} to return just the second parenthesized
subexpression (the number between the tags) for those 832 lines and
convert the output to a numeric matrix with 13 rows, one row for each
projection matrix.  To create a single projection matrix, just select
a row and reshape it as an $8 \times 8$ matrix (Figure~\ref{fe99}).

<<arel2, fig=TRUE, height=3, width=3, include=FALSE>>=
x<-gsub("(.*>)([0-9.]+)(<.*)", "\\2", arel[y] )

# convert to number
x<-matrix(as.numeric(x), nrow=13, byrow=TRUE)
stages=c("SD","SG", "SJ", "MJ", "LJ", "PR", "SA", "LA")

FE99<-matrix2( x[1,], stages)
image2(FE99, cex=.5)

@ 


\begin{figure}[t]
  \begin{center}
\includegraphics[height=3in, width=3in]{plot-arel2}
  \end{center}
  \caption{Projection matrix for \emph{Ardisia elliptica} at Forest Edge in 1999.}
     \label{fe99}
\end{figure}

You can also split the 13 matrices and format them into a single list
using \Rcmd{split}.     The final steps below are use to add the population and year to
the list names and  to display a vector of growth rates. 

<<arel3>>=

arel<-split(x,1:13)
arel<-lapply(arel, matrix2, stages)

years<-c("99", "00", "01")
sites<-c("FE", "TF", "HF", "AT")
pop<-c(paste(rep(sites, each=3), years, sep=""), "ST99")
names(arel)<-pop
sapply(arel, lambda)
@


\subsection*{Loading matrices expressed as vital rates}

In this final example, a table of vital rates (with html
markup) is used to construct matrix models of six  \emph{Orchis
  purpurea} populations from Jacquemyn et al. (2010).  The following
code downloads and formats the vital rate table.

<<vr>>=
 
url<-"http://www.esapubs.org/archive/ecol/E091/011/appendix-B.htm"

vrx<-readLines(url)

## find lines with numbers between html tags
y<-grep(">[0-9.]+<",  vrx, perl=TRUE)  

## remove html and save matrix elements
y<-gsub("(.*>)([0-9.]+)(<.*)", "\\2", vrx[y], perl=TRUE)

# arrange in table
vr<-matrix(as.numeric(y), ncol=15, byrow=TRUE)

# site-year labels (could use grep and gsub again)
n<-substr(vrx[seq(35,665, 18)], 55,64)
rownames(vr)<- gsub(" ", "_", gsub("'", "", n))
colnames(vr)<-c("psi",  "up", "pi", "ep", "d1", "d2", "d3", "d4", "d5", "d6", "g53", "g54", "g64", "g65", "g56")

vr[1:5,1:5]
@
Next, format the matrix of vital rates listed in equation 1 into an
expression.  Finally,  evaluate the \R~expression using a list of
vital rates from a single site to return a projection matrix.  You can also create a list of all 30 matrices
following the code in the earlier killer whale example.

<<orchid, keep.source=TRUE>>=
orpu<-expression( matrix2( c(
0,  0,  0,          0,              0,          psi*up*pi*ep,
d1, 0,  0,          0,              0,          0,
0,  d2, 0,          0,              0,          0,
0,  0,  d3*(1-g53), d4*(1-g54-g64), 0,          0,
0,  0,  d3*g53,     d4*g54,         d5*(1-g65), d6*g56,
0,  0,  0,          d4*g64,         d5*g65,     d6*(1-g56)
    ), c("pcorm", "tuber", "sdlng", "juv", "nonfl", "flwer"))
)
s1<-eval(orpu, as.list(vr[1,]) )
s1
@



\section*{References}

Brault, S., and H. Caswell. 1993. Pod-Specific Demography of Killer Whales (\emph{Orcinus Orca}). Ecology 74:1444-1454. 

Freville, H., B. Colas, M. Riba, H. Caswell, A. Mignot, E. Imbert,
I. Olivieri. 2004. Spatial and temporal demographic variability in the endemic plant
species \emph{Centaurea corymbosa} (Asteraceae).  Ecology 85: 694-703.

Gotelli, N.J. and A.M. Ellison. 2006. Forecasting extinction risk with
nonstationary matrix models. Ecological Applications 16:51-61.

Jacquemyn, H., R. Brys, E. Jongejans 2010. Seed limitation restricts
population growth in shaded populations of a perennial woodland
orchid. Ecology. 91:119-129.

Koop, A.L. and C.C. Horvitz. 2005. Projection matrix analysis of the
demography of an invasive, nonnative shrub (\emph{Ardisia
elliptica}). Ecology 86:2661-2672.

Morris, W.F. and D.F. Doak. 2005. How general are the
determinants of the stochastic population growth rate across nearby
sites? Ecological Monographs 75:119-137.



\end{document}
